
/**
 * 由 Fantastic-admin 提供技术支持
 * Powered by Fantastic-admin
 * Gitee  https://gitee.com/hooray/fantastic-admin
 * Github https://github.com/hooray/fantastic-admin
 */
  
var t,i,e,s,h,l,n,a,o,r,c,u,d,f,p,w,g,v,S,_,W,m,y,F,b,O,A,k,z,E,T,M,x,D,C,R,j,G,L,U,H,P,N,I,B,q,V,X,J,K,Q=Object.defineProperty,Y=(t,i,e)=>(((t,i,e)=>{i in t?Q(t,i,{enumerable:!0,configurable:!0,writable:!0,value:e}):t[i]=e})(t,"symbol"!=typeof i?i+"":i,e),e),Z=(t,i,e)=>{if(!i.has(t))throw TypeError("Cannot "+e)},$=(t,i,e)=>(Z(t,i,"read from private field"),e?e.call(t):i.get(t)),tt=(t,i,e)=>{if(i.has(t))throw TypeError("Cannot add the same private member more than once");i instanceof WeakSet?i.add(t):i.set(t,e)},it=(t,i,e,s)=>(Z(t,i,"write to private field"),s?s.call(t,e):i.set(t,e),e),et=(t,i,e,s)=>({set _(s){it(t,i,s,e)},get _(){return $(t,i,s)}}),st=(t,i,e)=>(Z(t,i,"access private method"),e);const ht="object"==typeof performance&&performance&&"function"==typeof performance.now?performance:Date,lt=new Set,nt=t=>t&&t===Math.floor(t)&&t>0&&isFinite(t),at=t=>nt(t)?t<=Math.pow(2,8)?Uint8Array:t<=Math.pow(2,16)?Uint16Array:t<=Math.pow(2,32)?Uint32Array:t<=Number.MAX_SAFE_INTEGER?ot:null:null;class ot extends Array{constructor(t){super(t),this.fill(0)}}const rt=class{constructor(i,e){if(Y(this,"heap"),Y(this,"length"),!$(rt,t))throw new TypeError("instantiate Stack using Stack.create(n)");this.heap=new e(i),this.length=0}static create(i){const e=at(i);if(!e)return[];it(rt,t,!0);const s=new rt(i,e);return it(rt,t,!1),s}push(t){this.heap[this.length++]=t}pop(){return this.heap[--this.length]}};let ct=rt;t=new WeakMap,tt(ct,t,!1);const ut=class{constructor(t){tt(this,F),tt(this,E),tt(this,C),tt(this,j),tt(this,L),tt(this,H),tt(this,N),tt(this,B),tt(this,V),tt(this,J),tt(this,i,void 0),tt(this,e,void 0),tt(this,s,void 0),tt(this,h,void 0),tt(this,l,void 0),Y(this,"ttl"),Y(this,"ttlResolution"),Y(this,"ttlAutopurge"),Y(this,"updateAgeOnGet"),Y(this,"updateAgeOnHas"),Y(this,"allowStale"),Y(this,"noDisposeOnSet"),Y(this,"noUpdateTTL"),Y(this,"maxEntrySize"),Y(this,"sizeCalculation"),Y(this,"noDeleteOnFetchRejection"),Y(this,"noDeleteOnStaleGet"),Y(this,"allowStaleOnFetchAbort"),Y(this,"allowStaleOnFetchRejection"),Y(this,"ignoreFetchAbort"),tt(this,n,void 0),tt(this,a,void 0),tt(this,o,void 0),tt(this,r,void 0),tt(this,c,void 0),tt(this,u,void 0),tt(this,d,void 0),tt(this,f,void 0),tt(this,p,void 0),tt(this,w,void 0),tt(this,g,void 0),tt(this,v,void 0),tt(this,S,void 0),tt(this,_,void 0),tt(this,W,void 0),tt(this,m,void 0),tt(this,y,void 0),tt(this,O,(()=>{})),tt(this,A,(()=>{})),tt(this,k,(()=>{})),tt(this,z,(()=>!1)),tt(this,M,(t=>{})),tt(this,x,((t,i,e)=>{})),tt(this,D,((t,i,e,s)=>{if(e||s)throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");return 0}));const{max:R=0,ttl:G,ttlResolution:U=1,ttlAutopurge:P,updateAgeOnGet:I,updateAgeOnHas:q,allowStale:X,dispose:K,disposeAfter:Q,noDisposeOnSet:Z,noUpdateTTL:et,maxSize:ht=0,maxEntrySize:ot=0,sizeCalculation:rt,fetchMethod:dt,noDeleteOnFetchRejection:ft,noDeleteOnStaleGet:pt,allowStaleOnFetchRejection:wt,allowStaleOnFetchAbort:gt,ignoreFetchAbort:vt}=t;if(0!==R&&!nt(R))throw new TypeError("max option must be a nonnegative integer");const St=R?at(R):Array;if(!St)throw new Error("invalid max value: "+R);if(it(this,i,R),it(this,e,ht),this.maxEntrySize=ot||$(this,e),this.sizeCalculation=rt,this.sizeCalculation){if(!$(this,e)&&!this.maxEntrySize)throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");if("function"!=typeof this.sizeCalculation)throw new TypeError("sizeCalculation set to non-function")}if(void 0!==dt&&"function"!=typeof dt)throw new TypeError("fetchMethod must be a function if specified");if(it(this,l,dt),it(this,m,!!dt),it(this,o,new Map),it(this,r,new Array(R).fill(void 0)),it(this,c,new Array(R).fill(void 0)),it(this,u,new St(R)),it(this,d,new St(R)),it(this,f,0),it(this,p,0),it(this,w,ct.create(R)),it(this,n,0),it(this,a,0),"function"==typeof K&&it(this,s,K),"function"==typeof Q?(it(this,h,Q),it(this,g,[])):(it(this,h,void 0),it(this,g,void 0)),it(this,W,!!$(this,s)),it(this,y,!!$(this,h)),this.noDisposeOnSet=!!Z,this.noUpdateTTL=!!et,this.noDeleteOnFetchRejection=!!ft,this.allowStaleOnFetchRejection=!!wt,this.allowStaleOnFetchAbort=!!gt,this.ignoreFetchAbort=!!vt,0!==this.maxEntrySize){if(0!==$(this,e)&&!nt($(this,e)))throw new TypeError("maxSize must be a positive integer if specified");if(!nt(this.maxEntrySize))throw new TypeError("maxEntrySize must be a positive integer if specified");st(this,E,T).call(this)}if(this.allowStale=!!X,this.noDeleteOnStaleGet=!!pt,this.updateAgeOnGet=!!I,this.updateAgeOnHas=!!q,this.ttlResolution=nt(U)||0===U?U:1,this.ttlAutopurge=!!P,this.ttl=G||0,this.ttl){if(!nt(this.ttl))throw new TypeError("ttl must be a positive integer if specified");st(this,F,b).call(this)}if(0===$(this,i)&&0===this.ttl&&0===$(this,e))throw new TypeError("At least one of max, maxSize, or ttl is required");if(!this.ttlAutopurge&&!$(this,i)&&!$(this,e)){const t="LRU_CACHE_UNBOUNDED";if((t=>!lt.has(t))(t)){lt.add(t);((t,i,e,s)=>{"object"==typeof process&&process&&"function"==typeof process.emitWarning&&process.emitWarning(t,i,e,s)})("TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.","UnboundedCacheWarning",t,ut)}}}static unsafeExposeInternals(t){return{starts:$(t,S),ttls:$(t,_),sizes:$(t,v),keyMap:$(t,o),keyList:$(t,r),valList:$(t,c),next:$(t,u),prev:$(t,d),get head(){return $(t,f)},get tail(){return $(t,p)},free:$(t,w),isBackgroundFetch:i=>{var e;return st(e=t,B,q).call(e,i)},backgroundFetch:(i,e,s,h)=>{var l;return st(l=t,N,I).call(l,i,e,s,h)},moveToTail:i=>{var e;return st(e=t,J,K).call(e,i)},indexes:i=>{var e;return st(e=t,C,R).call(e,i)},rindexes:i=>{var e;return st(e=t,j,G).call(e,i)},isStale:i=>{var e;return $(e=t,z).call(e,i)}}}get max(){return $(this,i)}get maxSize(){return $(this,e)}get calculatedSize(){return $(this,a)}get size(){return $(this,n)}get fetchMethod(){return $(this,l)}get dispose(){return $(this,s)}get disposeAfter(){return $(this,h)}getRemainingTTL(t){return $(this,o).has(t)?1/0:0}*entries(){for(const t of st(this,C,R).call(this))void 0===$(this,c)[t]||void 0===$(this,r)[t]||st(this,B,q).call(this,$(this,c)[t])||(yield[$(this,r)[t],$(this,c)[t]])}*rentries(){for(const t of st(this,j,G).call(this))void 0===$(this,c)[t]||void 0===$(this,r)[t]||st(this,B,q).call(this,$(this,c)[t])||(yield[$(this,r)[t],$(this,c)[t]])}*keys(){for(const t of st(this,C,R).call(this)){const i=$(this,r)[t];void 0===i||st(this,B,q).call(this,$(this,c)[t])||(yield i)}}*rkeys(){for(const t of st(this,j,G).call(this)){const i=$(this,r)[t];void 0===i||st(this,B,q).call(this,$(this,c)[t])||(yield i)}}*values(){for(const t of st(this,C,R).call(this)){void 0===$(this,c)[t]||st(this,B,q).call(this,$(this,c)[t])||(yield $(this,c)[t])}}*rvalues(){for(const t of st(this,j,G).call(this)){void 0===$(this,c)[t]||st(this,B,q).call(this,$(this,c)[t])||(yield $(this,c)[t])}}[Symbol.iterator](){return this.entries()}find(t,i={}){for(const e of st(this,C,R).call(this)){const s=$(this,c)[e],h=st(this,B,q).call(this,s)?s.__staleWhileFetching:s;if(void 0!==h&&t(h,$(this,r)[e],this))return this.get($(this,r)[e],i)}}forEach(t,i=this){for(const e of st(this,C,R).call(this)){const s=$(this,c)[e],h=st(this,B,q).call(this,s)?s.__staleWhileFetching:s;void 0!==h&&t.call(i,h,$(this,r)[e],this)}}rforEach(t,i=this){for(const e of st(this,j,G).call(this)){const s=$(this,c)[e],h=st(this,B,q).call(this,s)?s.__staleWhileFetching:s;void 0!==h&&t.call(i,h,$(this,r)[e],this)}}purgeStale(){let t=!1;for(const i of st(this,j,G).call(this,{allowStale:!0}))$(this,z).call(this,i)&&(this.delete($(this,r)[i]),t=!0);return t}dump(){const t=[];for(const i of st(this,C,R).call(this,{allowStale:!0})){const e=$(this,r)[i],s=$(this,c)[i],h=st(this,B,q).call(this,s)?s.__staleWhileFetching:s;if(void 0===h||void 0===e)continue;const l={value:h};if($(this,_)&&$(this,S)){l.ttl=$(this,_)[i];const t=ht.now()-$(this,S)[i];l.start=Math.floor(Date.now()-t)}$(this,v)&&(l.size=$(this,v)[i]),t.unshift([e,l])}return t}load(t){this.clear();for(const[i,e]of t){if(e.start){const t=Date.now()-e.start;e.start=ht.now()-t}this.set(i,e.value,e)}}set(t,e,l={}){var a,f,v;const{ttl:S=this.ttl,start:O,noDisposeOnSet:z=this.noDisposeOnSet,sizeCalculation:E=this.sizeCalculation,status:T}=l;let{noUpdateTTL:C=this.noUpdateTTL}=l;const R=$(this,D).call(this,t,e,l.size||0,E);if(this.maxEntrySize&&R>this.maxEntrySize)return T&&(T.set="miss",T.maxEntrySizeExceeded=!0),this.delete(t),this;let j=0===$(this,n)?void 0:$(this,o).get(t);if(void 0===j)j=0===$(this,n)?$(this,p):0!==$(this,w).length?$(this,w).pop():$(this,n)===$(this,i)?st(this,H,P).call(this,!1):$(this,n),$(this,r)[j]=t,$(this,c)[j]=e,$(this,o).set(t,j),$(this,u)[$(this,p)]=j,$(this,d)[j]=$(this,p),it(this,p,j),et(this,n)._++,$(this,x).call(this,j,R,T),T&&(T.set="add"),C=!1;else{st(this,J,K).call(this,j);const i=$(this,c)[j];if(e!==i){if($(this,m)&&st(this,B,q).call(this,i)?i.__abortController.abort(new Error("replaced")):z||($(this,W)&&(null==(a=$(this,s))||a.call(this,i,t,"set")),$(this,y)&&(null==(f=$(this,g))||f.push([i,t,"set"]))),$(this,M).call(this,j),$(this,x).call(this,j,R,T),$(this,c)[j]=e,T){T.set="replace";const t=i&&st(this,B,q).call(this,i)?i.__staleWhileFetching:i;void 0!==t&&(T.oldValue=t)}}else T&&(T.set="update")}if(0===S||$(this,_)||st(this,F,b).call(this),$(this,_)&&(C||$(this,k).call(this,j,S,O),T&&$(this,A).call(this,T,j)),!z&&$(this,y)&&$(this,g)){const t=$(this,g);let i;for(;i=null==t?void 0:t.shift();)null==(v=$(this,h))||v.call(this,...i)}return this}pop(){var t;try{for(;$(this,n);){const t=$(this,c)[$(this,f)];if(st(this,H,P).call(this,!0),st(this,B,q).call(this,t)){if(t.__staleWhileFetching)return t.__staleWhileFetching}else if(void 0!==t)return t}}finally{if($(this,y)&&$(this,g)){const i=$(this,g);let e;for(;e=null==i?void 0:i.shift();)null==(t=$(this,h))||t.call(this,...e)}}}has(t,i={}){const{updateAgeOnHas:e=this.updateAgeOnHas,status:s}=i,h=$(this,o).get(t);if(void 0!==h){const t=$(this,c)[h];if(st(this,B,q).call(this,t)&&void 0===t.__staleWhileFetching)return!1;if(!$(this,z).call(this,h))return e&&$(this,O).call(this,h),s&&(s.has="hit",$(this,A).call(this,s,h)),!0;s&&(s.has="stale",$(this,A).call(this,s,h))}else s&&(s.has="miss");return!1}peek(t,i={}){const{allowStale:e=this.allowStale}=i,s=$(this,o).get(t);if(void 0!==s&&(e||!$(this,z).call(this,s))){const t=$(this,c)[s];return st(this,B,q).call(this,t)?t.__staleWhileFetching:t}}async fetch(t,i={}){const{allowStale:e=this.allowStale,updateAgeOnGet:s=this.updateAgeOnGet,noDeleteOnStaleGet:h=this.noDeleteOnStaleGet,ttl:l=this.ttl,noDisposeOnSet:n=this.noDisposeOnSet,size:a=0,sizeCalculation:r=this.sizeCalculation,noUpdateTTL:u=this.noUpdateTTL,noDeleteOnFetchRejection:d=this.noDeleteOnFetchRejection,allowStaleOnFetchRejection:f=this.allowStaleOnFetchRejection,ignoreFetchAbort:p=this.ignoreFetchAbort,allowStaleOnFetchAbort:w=this.allowStaleOnFetchAbort,context:g,forceRefresh:v=!1,status:S,signal:_}=i;if(!$(this,m))return S&&(S.fetch="get"),this.get(t,{allowStale:e,updateAgeOnGet:s,noDeleteOnStaleGet:h,status:S});const W={allowStale:e,updateAgeOnGet:s,noDeleteOnStaleGet:h,ttl:l,noDisposeOnSet:n,size:a,sizeCalculation:r,noUpdateTTL:u,noDeleteOnFetchRejection:d,allowStaleOnFetchRejection:f,allowStaleOnFetchAbort:w,ignoreFetchAbort:p,status:S,signal:_};let y=$(this,o).get(t);if(void 0===y){S&&(S.fetch="miss");const i=st(this,N,I).call(this,t,y,W,g);return i.__returned=i}{const i=$(this,c)[y];if(st(this,B,q).call(this,i)){const t=e&&void 0!==i.__staleWhileFetching;return S&&(S.fetch="inflight",t&&(S.returnedStale=!0)),t?i.__staleWhileFetching:i.__returned=i}const h=$(this,z).call(this,y);if(!v&&!h)return S&&(S.fetch="hit"),st(this,J,K).call(this,y),s&&$(this,O).call(this,y),S&&$(this,A).call(this,S,y),i;const l=st(this,N,I).call(this,t,y,W,g),n=void 0!==l.__staleWhileFetching&&e;return S&&(S.fetch=h?"stale":"refresh",n&&h&&(S.returnedStale=!0)),n?l.__staleWhileFetching:l.__returned=l}}get(t,i={}){const{allowStale:e=this.allowStale,updateAgeOnGet:s=this.updateAgeOnGet,noDeleteOnStaleGet:h=this.noDeleteOnStaleGet,status:l}=i,n=$(this,o).get(t);if(void 0!==n){const i=$(this,c)[n],a=st(this,B,q).call(this,i);return l&&$(this,A).call(this,l,n),$(this,z).call(this,n)?(l&&(l.get="stale"),a?(l&&e&&void 0!==i.__staleWhileFetching&&(l.returnedStale=!0),e?i.__staleWhileFetching:void 0):(h||this.delete(t),l&&e&&(l.returnedStale=!0),e?i:void 0)):(l&&(l.get="hit"),a?i.__staleWhileFetching:(st(this,J,K).call(this,n),s&&$(this,O).call(this,n),i))}l&&(l.get="miss")}delete(t){var i,e,l,a;let v=!1;if(0!==$(this,n)){const h=$(this,o).get(t);if(void 0!==h)if(v=!0,1===$(this,n))this.clear();else{$(this,M).call(this,h);const l=$(this,c)[h];st(this,B,q).call(this,l)?l.__abortController.abort(new Error("deleted")):($(this,W)||$(this,y))&&($(this,W)&&(null==(i=$(this,s))||i.call(this,l,t,"delete")),$(this,y)&&(null==(e=$(this,g))||e.push([l,t,"delete"]))),$(this,o).delete(t),$(this,r)[h]=void 0,$(this,c)[h]=void 0,h===$(this,p)?it(this,p,$(this,d)[h]):h===$(this,f)?it(this,f,$(this,u)[h]):($(this,u)[$(this,d)[h]]=$(this,u)[h],$(this,d)[$(this,u)[h]]=$(this,d)[h]),et(this,n)._--,$(this,w).push(h)}}if($(this,y)&&(null==(l=$(this,g))?void 0:l.length)){const t=$(this,g);let i;for(;i=null==t?void 0:t.shift();)null==(a=$(this,h))||a.call(this,...i)}return v}clear(){var t,i,e;for(const h of st(this,j,G).call(this,{allowStale:!0})){const e=$(this,c)[h];if(st(this,B,q).call(this,e))e.__abortController.abort(new Error("deleted"));else{const l=$(this,r)[h];$(this,W)&&(null==(t=$(this,s))||t.call(this,e,l,"delete")),$(this,y)&&(null==(i=$(this,g))||i.push([e,l,"delete"]))}}if($(this,o).clear(),$(this,c).fill(void 0),$(this,r).fill(void 0),$(this,_)&&$(this,S)&&($(this,_).fill(0),$(this,S).fill(0)),$(this,v)&&$(this,v).fill(0),it(this,f,0),it(this,p,0),$(this,w).length=0,it(this,a,0),it(this,n,0),$(this,y)&&$(this,g)){const t=$(this,g);let i;for(;i=null==t?void 0:t.shift();)null==(e=$(this,h))||e.call(this,...i)}}};let dt=ut;i=new WeakMap,e=new WeakMap,s=new WeakMap,h=new WeakMap,l=new WeakMap,n=new WeakMap,a=new WeakMap,o=new WeakMap,r=new WeakMap,c=new WeakMap,u=new WeakMap,d=new WeakMap,f=new WeakMap,p=new WeakMap,w=new WeakMap,g=new WeakMap,v=new WeakMap,S=new WeakMap,_=new WeakMap,W=new WeakMap,m=new WeakMap,y=new WeakMap,F=new WeakSet,b=function(){const t=new ot($(this,i)),e=new ot($(this,i));it(this,_,t),it(this,S,e),it(this,k,((i,s,h=ht.now())=>{if(e[i]=0!==s?h:0,t[i]=s,0!==s&&this.ttlAutopurge){const t=setTimeout((()=>{$(this,z).call(this,i)&&this.delete($(this,r)[i])}),s+1);t.unref&&t.unref()}})),it(this,O,(i=>{e[i]=0!==t[i]?ht.now():0})),it(this,A,((i,l)=>{if(t[l]){const n=t[l],a=e[l];i.ttl=n,i.start=a,i.now=s||h(),i.remainingTTL=i.now+n-a}}));let s=0;const h=()=>{const t=ht.now();if(this.ttlResolution>0){s=t;const i=setTimeout((()=>s=0),this.ttlResolution);i.unref&&i.unref()}return t};this.getRemainingTTL=i=>{const l=$(this,o).get(i);return void 0===l?0:0===t[l]||0===e[l]?1/0:e[l]+t[l]-(s||h())},it(this,z,(i=>0!==t[i]&&0!==e[i]&&(s||h())-e[i]>t[i]))},O=new WeakMap,A=new WeakMap,k=new WeakMap,z=new WeakMap,E=new WeakSet,T=function(){const t=new ot($(this,i));it(this,a,0),it(this,v,t),it(this,M,(i=>{it(this,a,$(this,a)-t[i]),t[i]=0})),it(this,D,((t,i,e,s)=>{if(st(this,B,q).call(this,i))return 0;if(!nt(e)){if(!s)throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");if("function"!=typeof s)throw new TypeError("sizeCalculation must be a function");if(e=s(i,t),!nt(e))throw new TypeError("sizeCalculation return invalid (expect positive integer)")}return e})),it(this,x,((i,s,h)=>{if(t[i]=s,$(this,e)){const s=$(this,e)-t[i];for(;$(this,a)>s;)st(this,H,P).call(this,!0)}it(this,a,$(this,a)+t[i]),h&&(h.entrySize=s,h.totalCalculatedSize=$(this,a))}))},M=new WeakMap,x=new WeakMap,D=new WeakMap,C=new WeakSet,R=function*({allowStale:t=this.allowStale}={}){if($(this,n))for(let i=$(this,p);st(this,L,U).call(this,i)&&(!t&&$(this,z).call(this,i)||(yield i),i!==$(this,f));)i=$(this,d)[i]},j=new WeakSet,G=function*({allowStale:t=this.allowStale}={}){if($(this,n))for(let i=$(this,f);st(this,L,U).call(this,i)&&(!t&&$(this,z).call(this,i)||(yield i),i!==$(this,p));)i=$(this,u)[i]},L=new WeakSet,U=function(t){return void 0!==t&&$(this,o).get($(this,r)[t])===t},H=new WeakSet,P=function(t){var i,e;const h=$(this,f),l=$(this,r)[h],a=$(this,c)[h];return $(this,m)&&st(this,B,q).call(this,a)?a.__abortController.abort(new Error("evicted")):($(this,W)||$(this,y))&&($(this,W)&&(null==(i=$(this,s))||i.call(this,a,l,"evict")),$(this,y)&&(null==(e=$(this,g))||e.push([a,l,"evict"]))),$(this,M).call(this,h),t&&($(this,r)[h]=void 0,$(this,c)[h]=void 0,$(this,w).push(h)),1===$(this,n)?(it(this,f,it(this,p,0)),$(this,w).length=0):it(this,f,$(this,u)[h]),$(this,o).delete(l),et(this,n)._--,h},N=new WeakSet,I=function(t,i,e,s){const h=void 0===i?void 0:$(this,c)[i];if(st(this,B,q).call(this,h))return h;const n=new AbortController,{signal:a}=e;null==a||a.addEventListener("abort",(()=>n.abort(a.reason)),{signal:n.signal});const r={signal:n.signal,options:e,context:s},u=(s,h=!1)=>{const{aborted:l}=n.signal,a=e.ignoreFetchAbort&&void 0!==s;if(e.status&&(l&&!h?(e.status.fetchAborted=!0,e.status.fetchError=n.signal.reason,a&&(e.status.fetchAbortIgnored=!0)):e.status.fetchResolved=!0),l&&!a&&!h)return d(n.signal.reason);const o=f;return $(this,c)[i]===f&&(void 0===s?o.__staleWhileFetching?$(this,c)[i]=o.__staleWhileFetching:this.delete(t):(e.status&&(e.status.fetchUpdated=!0),this.set(t,s,r.options))),s},d=s=>{const{aborted:h}=n.signal,l=h&&e.allowStaleOnFetchAbort,a=l||e.allowStaleOnFetchRejection,o=a||e.noDeleteOnFetchRejection,r=f;if($(this,c)[i]===f){!o||void 0===r.__staleWhileFetching?this.delete(t):l||($(this,c)[i]=r.__staleWhileFetching)}if(a)return e.status&&void 0!==r.__staleWhileFetching&&(e.status.returnedStale=!0),r.__staleWhileFetching;if(r.__returned===r)throw s};e.status&&(e.status.fetchDispatched=!0);const f=new Promise(((i,s)=>{var a;const o=null==(a=$(this,l))?void 0:a.call(this,t,h,r);o&&o instanceof Promise&&o.then((t=>i(t)),s),n.signal.addEventListener("abort",(()=>{e.ignoreFetchAbort&&!e.allowStaleOnFetchAbort||(i(),e.allowStaleOnFetchAbort&&(i=t=>u(t,!0)))}))})).then(u,(t=>(e.status&&(e.status.fetchRejected=!0,e.status.fetchError=t),d(t)))),p=Object.assign(f,{__abortController:n,__staleWhileFetching:h,__returned:void 0});return void 0===i?(this.set(t,p,{...r.options,status:void 0}),i=$(this,o).get(t)):$(this,c)[i]=p,p},B=new WeakSet,q=function(t){if(!$(this,m))return!1;const i=t;return!!i&&i instanceof Promise&&i.hasOwnProperty("__staleWhileFetching")&&i.__abortController instanceof AbortController},V=new WeakSet,X=function(t,i){$(this,d)[i]=t,$(this,u)[t]=i},J=new WeakSet,K=function(t){t!==$(this,p)&&(t===$(this,f)?it(this,f,$(this,u)[t]):st(this,V,X).call(this,$(this,d)[t],$(this,u)[t]),st(this,V,X).call(this,$(this,p),t),it(this,p,t))};const ft=dt;export{ft as W};
